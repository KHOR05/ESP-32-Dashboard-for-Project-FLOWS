<!DOCTYPE html>
<html lang="en">  
<head>
  <meta charset="UTF-8">   
  <title>FLOWS IoT Dashboard</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üíß</text></svg>">

  <style>
    /* Background colour settings */
    :root {
      --bg-color: #46ccea;
      --text-color: #000;
      --card-bg: #f9f9f9;
      --value-color: #333;
    }

    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background 0.3s, color 0.3s;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 55px;
      margin-top: 20px;
    }

    /* Card settings */
    .card {
      background: var(--card-bg);
      padding: 20px;
      width: 280px;
      border-radius: 12px;
      box-shadow: 0px 4px 10px rgba(0,0,0,0.1);
      transition: background 0.3s;
    }

    /* Chart settings */
    h2 { margin: 10px 0; }
    #charts { display: flex; justify-content: center; gap: 55px; flex-wrap: wrap; margin-top: 20px; }
    canvas { background: #f7f7f7; border-radius: 20px; padding: 10px; }
    .value { font-weight: bold; font-size: 2em; color: var(--value-color); }
    .ok { color: green; font-weight: bold; }
    .leak { color: red; font-weight: bold; }
    .online { color: green; font-weight: bold; }
    .offline { color: red; font-weight: bold; }

    /* Dark mode variables */
    body.dark {
      --bg-color: #121212;
      --text-color: #f5f5f5;
      --card-bg: #1e1e1e;
      --value-color: #f5f5f5;
    }

    /* Container for top buttons */
    .top-buttons {
      position: absolute;
      top: 20px;
      right: 25px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Shared button style */
    .top-buttons button {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s;
    }

    /* Dark mode toggle button */
    #themeToggle {
      background: #333;
      color: white;
    }
    #themeToggle:hover {
      background: #555;
    }

    /* Test notification button */
    #testNotificationBtn {
      background: #007BFF;
      color: white;
    }
    #testNotificationBtn:hover {
      background: #0056b3;
    }
  </style>
</head>
<body>

  <!-- Top-right buttons -->
  <div class="top-buttons">
    <button id="themeToggle">üåô Dark Mode</button>
    <button id="testNotificationBtn">üîî Test Notification</button>
  </div>

  <h1>FLOWS (Fire Line Overflow & Water Leak Sensor)</h1>
  <h1>with IoT by using ESP32</h1>

  <div class="container">
    <div class="card">
      <h2>üíß Water Flow Rate</h2>
      <p><span id="flow" class="value">--</span> L/min</p>
    </div>

    <div class="card">
      <h2>‚è± Water Pressure</h2>
      <p><span id="pressure" class="value">--</span> Psi</p>
    </div>

    <div class="card">
      <h2>‚ö° System Status</h2>
      <p id="status" class="value">--</p>
    </div>

    <div class="card"> 
      <h2>üåê Server Connection</h2> 
      <p id="serverStatus" class="offline">üî¥ Disconnected</p>
    </div>

    <div class="card">
      <h2>üîå ESP32 Device</h2>
      <p id="esp32Status" class="offline">üî¥ Offline</p>
    </div>
  </div>

  <div id="charts">
    <canvas id="flowChart" width="400" height="200"></canvas>
    <canvas id="pressureChart" width="400" height="200"></canvas>
  </div>


<script>
  // üåô Dark/Light Mode Toggle
  const themeToggle = document.getElementById("themeToggle");

  // ---- Chart.js Setup ----
  const MAX_POINTS = 720; // 1 hour at 5s interval

  function createChart(ctx, label, color) {
    return new Chart(ctx, {
      type: "line",
      data: { labels: [], datasets: [{ label, data: [], borderColor: color, fill: false }] },
      options: {
        responsive: true,
        animation: false,
        scales: { x: { display: false }, y: { beginAtZero: true } }
      }
    });
  }

  const flowChart = createChart(document.getElementById("flowChart"), "Flow (L/min)", "blue");
  const pressureChart = createChart(document.getElementById("pressureChart"), "Pressure (psi)", "red");

  // Function to update chart colors based on theme
  function updateChartColors() {
    if (document.body.classList.contains("dark")) {
      // Dark mode chart style
      flowChart.options.scales.x.ticks.color = "#f5f5f5";
      flowChart.options.scales.y.ticks.color = "#f5f5f5";
      flowChart.options.scales.x.grid.color = "#444";
      flowChart.options.scales.y.grid.color = "#444";
      flowChart.data.datasets[0].borderColor = "#4FC3F7"; // light blue

      pressureChart.options.scales.x.ticks.color = "#f5f5f5";
      pressureChart.options.scales.y.ticks.color = "#f5f5f5";
      pressureChart.options.scales.x.grid.color = "#444";
      pressureChart.options.scales.y.grid.color = "#444";
      pressureChart.data.datasets[0].borderColor = "#FF3838"; // light red

      document.getElementById("flowChart").style.background = "#1e1e1e";
      document.getElementById("pressureChart").style.background = "#1e1e1e";

    } else {
      // Light mode chart style
      flowChart.options.scales.x.ticks.color = "#000";
      flowChart.options.scales.y.ticks.color = "#000";
      flowChart.options.scales.x.grid.color = "#ccc";
      flowChart.options.scales.y.grid.color = "#ccc";
      flowChart.data.datasets[0].borderColor = "blue";

      pressureChart.options.scales.x.ticks.color = "#000";
      pressureChart.options.scales.y.ticks.color = "#000";
      pressureChart.options.scales.x.grid.color = "#ccc";
      pressureChart.options.scales.y.grid.color = "#ccc";
      pressureChart.data.datasets[0].borderColor = "red";

      document.getElementById("flowChart").style.background = "#f7f7f7";
      document.getElementById("pressureChart").style.background = "#f7f7f7";
    }

    flowChart.update();
    pressureChart.update();
  }

  // üåô Dark/Light Mode Toggle button
  themeToggle.addEventListener("click", () => {
    document.body.classList.toggle("dark");
    if (document.body.classList.contains("dark")) {
      themeToggle.textContent = "‚òÄÔ∏è Light Mode";
    } else {
      themeToggle.textContent = "üåô Dark Mode";
    }
    updateChartColors();
  });

  // ---- AddData, Save, Load History functions ----
  function addData(chart, value) {
    if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length === 0) {
      console.error("‚ö†Ô∏è Chart not ready when adding");
      return;
    }

    chart.data.labels.push(new Date().toLocaleTimeString());
    chart.data.datasets[0].data.push(value);

    if (chart.data.labels.length > MAX_POINTS) {
      chart.data.labels.shift();
      chart.data.datasets[0].data.shift();
    }
    chart.update();
  }

  function saveHistory(key, chart) {
    if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length === 0) return;

    localStorage.setItem(key, JSON.stringify({
      labels: chart.data.labels || [],
      data: chart.data.datasets[0].data || []
    }));
  }

  function loadHistory(key, chart) {
    const saved = localStorage.getItem(key);
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        chart.data.labels = Array.isArray(parsed.labels) ? parsed.labels : [];
        chart.data.datasets[0].data = Array.isArray(parsed.data) ? parsed.data : [];
        chart.update();
      } catch (e) {
        console.warn("‚ö†Ô∏è Failed to load history for", key, e);
      }
    }
  }

  // ---- MQTT.js Setup ----
  const client = mqtt.connect("wss://broker.hivemq.com:8884/mqtt");
  const serverStatusEl = document.getElementById("serverStatus");
  const esp32StatusEl = document.getElementById("esp32Status");

  client.on("connect", () => {
    console.log("‚úÖ Connected to HiveMQ broker via WebSocket");
    serverStatusEl.innerText = "üü¢ Online";
    serverStatusEl.className = "online";

    client.subscribe("esp32/flow");
    client.subscribe("esp32/pressure");
    client.subscribe("esp32/status");
    client.subscribe("esp32/online");
  });

  client.on("error", () => {
    serverStatusEl.innerText = "üî¥ Disconnected";
    serverStatusEl.className = "offline";
  });
  client.on("close", () => {
    serverStatusEl.innerText = "üî¥ Disconnected";
    serverStatusEl.className = "offline";
  });
  client.on("offline", () => {
    serverStatusEl.innerText = "üî¥ Disconnected";
    serverStatusEl.className = "offline";
  });

  // Request browser notification permission
  if ("Notification" in window && Notification.permission !== "granted") {
    Notification.requestPermission();
  }

  // Function to send notification + backend email call
  function sendLeakNotification() {
    // üîî Browser notification
    if ("Notification" in window && Notification.permission === "granted") {
      new Notification("üö® Leak Alert!", {
        body: "Water leak detected by ESP32!",
        icon: "https://cdn-icons-png.flaticon.com/512/2913/2913551.png"
      });
    }

    // üîä Optional alert sound
    const audio = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    audio.play();

    // üìß Call backend to send email via SendGrid
    fetch("https://esp-32-dashboard-for-project-flows.onrender.com/send-email", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        subject: "Leak Alert üö®",
        message: "Water leak detected from ESP32 system!"
      })
    })
      .then(async (res) => {
        const data = await res.json();
        console.log("üìß Email API response:", data);

        if (res.ok && data.success) {
          alert("‚úÖ Notification email sent successfully!");
        } else {
          alert("‚ùå Failed to send email. Check server logs.");
        }
      })
      .catch((err) => {
        console.error("‚ùå Error calling email API:", err);
        alert("‚ö†Ô∏è Could not reach email server.");
      });
  }


  // Bind test notification button
  document.getElementById("testNotificationBtn").addEventListener("click", () => {
  const statusEl = document.getElementById("status");

  // Set to leak detected
  statusEl.innerText = "üö® Water Leak Detected! (TEST)";
  statusEl.className = "leak";
  sendLeakNotification();

  console.log("‚úÖ Test Leak Notification triggered");

  // Auto-revert back after 5 seconds
  setTimeout(() => {
    statusEl.innerText = "‚úÖ No Water Leak Detected";
    statusEl.className = "ok";
    console.log("üîÑ System status auto-reset to normal");
  }, 5000); // 5000 ms = 5 seconds
});


  // Handle MQTT messages
  client.on("message", (topic, message) => {
    const value = message.toString();
    console.log("üì© " + topic + ": " + value);

    if (topic === "esp32/flow") {
      document.getElementById("flow").innerText = value;
      addData(flowChart, parseFloat(value));
      saveHistory("flowHistory", flowChart);
      localStorage.setItem("flow", value);
    }

    if (topic === "esp32/pressure") {
      document.getElementById("pressure").innerText = value;
      addData(pressureChart, parseFloat(value));
      saveHistory("pressureHistory", pressureChart);
      localStorage.setItem("pressure", value);
    }

    if (topic === "esp32/status") {
      const statusEl = document.getElementById("status");
      if (value === "LEAK") {
        statusEl.innerText = "üö® Water Leak Detected!";
        statusEl.className = "leak";
        sendLeakNotification();  // trigger notification
      } else {
        statusEl.innerText = "‚úÖ No Water Leak Detected";
        statusEl.className = "ok";
      }
      localStorage.setItem("status", value);
    }

    if (topic === "esp32/online") {
      if (value === "online") {
        esp32StatusEl.innerText = "üü¢ Online";
        esp32StatusEl.className = "online";
      } else {
        esp32StatusEl.innerText = "üî¥ Offline";
        esp32StatusEl.className = "offline";
      }
    }
  });

  // On page load
  window.onload = () => {
    loadHistory("flowHistory", flowChart);
    loadHistory("pressureHistory", pressureChart);

    if (localStorage.getItem("flow")) {
      document.getElementById("flow").innerText = localStorage.getItem("flow");
    }
    if (localStorage.getItem("pressure")) {
      document.getElementById("pressure").innerText = localStorage.getItem("pressure");
    }
    if (localStorage.getItem("status")) {
      const statusEl = document.getElementById("status");
      if (localStorage.getItem("status") === "LEAK") {
        statusEl.innerText = "üö® Water Leak Detected!";
        statusEl.className = "leak";
      } else {
        statusEl.innerText = "‚úÖ No Water Leak Detected";
        statusEl.className = "ok";
      }
    }

    updateChartColors();
  };
</script>

</body>
</html>
